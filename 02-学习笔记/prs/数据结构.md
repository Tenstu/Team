# 数据
## 定义
数据是信息的载体, 是描述客观事物的书、字符, 以及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。
## 分类
### 数值性数据
包括整数、浮点数、复数、双精度数等, 主要用于工程和科学计算, 以及商业事务处理。
### 非数值数据
包括字符和字符串, 以及文字、图形、图像、语音等数据。
## 数据元素
数据的基本单位。一个数据元素可由若干个数据项组成, 它是一个数据整体中相对独立的单位。
## 数据项
### 初等项
在数据处理时不能再分割的最小单位
### 组合项
由若干个初等项组合而成，也可有多个组合项再次组成一个新的组合项
# 数据结构
## 定义
由某一数据元素的集合和该集合中数据元素之间的关系组成
## 分类
### 线性结构(线性表)
#### 定义
所有数据元素都按某种次序排列在一个序列中。
#### 特点
对于线性结构类中每一数据元素, 除第一个元素外, 其他每一个元素有且仅有一个直接前驱, 第一个元素没有前驱。除最后一个元素外,其他每一个元素都有且仅有一个元素没有后继
#### 直接存取结构
可以存取某一指定想而不需先访问其先驱。例: 数组、文件
#### 顺序存取结构
只能从序列中第一个元素起, 按序逐个访问直到指定的元素。例: 栈、队列、优先队列。
#### 字典结构
通过关键码(key)进行索引。
### 非线性结构
#### 定义
各个数据元素不再保持在一个线性序列中, 每个数据元素可以有零个或多个其他数据元素发生联系
#### 层次结构
按层次划分的数据元素的集合, 指定层次上元素可以有零个或多个处于下一个层次上的直接所属下层元素。例: 树形结构
##### 树形结构
树中的元素叫做结点, 树可以为空, 也可以不为空, 若树不为空, 它有一个叫做根的结点, 其他结点都是由根派生出来的。除根以外, 每一个结点都有一个处于该节点直接上层的特点。
#### 群结构
所有元素之间无顺序关系。例: 集合
##### 图结构
有图的顶点集合和连接顶点的边集合组成
##### 网络结构
在图结构的基础上给每条边赋予一个权值, 这个权值指明了遍历图时经过此边时的耗费。
# 核心技术: 分解与抽象
## 分解
划分出数据的层次(数据—数据元素—数据项)
## 抽象
舍弃数据元素的具体内容, 得到数据的逻辑结构
## 数据的逻辑结构(数据结构)
从解决问题的需要出发, 为实现必要的功能所建立的数据结构。属于用户的视图, 是面向问题的。根据问题索要实现的功能建立
## 数据的物理结构
指数据应该如何在计算机中存放, 是数据结构的物理存储方式。属于具体实现的视图, 是面向计算机的。根据问题所要求的响应速度、处理时间、修改时间、存储空间和单位时间的处理量等建立, 是逻辑数据的存储映像。
## 数据结构的存储结构
### 基本存储方法
#### 顺序存储方法
将逻辑上相邻的元素存放到物理物理位置上相邻的存储单元中, 数据元素之间的逻辑关系有存储单元的邻接位置关系来体现。由此得到的存储表示称为顺序存储结构。通常由一维数组来描述
#### 链接存储方法
不要求逻辑上相邻
# 线性表
1. 线性表($linear$ $list$)是$n$个具有相同特性的数据元素的有限序列。
2. 线性表在逻辑上是线性结构，在物理结构上并不一定是连续的。
## 存储方式
1. 顺序存储
2. 链式存储
顺序存储的线性表叫顺序表，链式存储的线性表叫链表。
## 顺序表
顺序表使用一段物理地址连续的存储单元依次存储数据元素的线性结构。一般情况下采用数组存储，在数组上完成增删改查。
### 空间分配
#### 静态分配
数组的大小固定。
#### 动态分配
##### 实现机制
###### 初始分配
- 开始时，顺序表可能分配一个初始大小的内存块来存储元素。
###### 扩容机制
- 当顺序表中的元素数量达到当前内存块的容量时，需要进行扩容操作。
- 扩容通常是通过申请一块更大的内存空间，将原有数据复制到新的内存空间中，并释放旧的内存空间。
- 扩容后，顺序表的容量增加，通常会增加一倍或按一定的增长策略增加，以减少频繁的扩容操作。
###### 缩容机制
- 当顺序表中的元素数量减少到一定程度时，可能需要缩小内存空间以节省资源。
- 缩容操作与扩容类似，申请一块较小的内存空间，将数据复制过去，并释放旧的内存空间。
## 栈
一种限制访问端口的线性表（后进先出），元素的插入（入栈/压栈）和删除（出栈/弹栈）仅在栈顶进行。
### 核心操作
- `push()`：元素入栈（压栈）。  
- `pop()`：栈顶元素出栈（弹栈）。  
- `top()`：获取栈顶元素（不删除）。  
- `isEmpty()`：判断栈是否为空。  
### 出栈顺序的分隔定理
设$k$是最后一个出栈的，那么$k$把序列一分为二；在$k$之前入栈的元素，一定比在$k$之后入栈的元素，要提前出栈。
### 顺序栈
基于数组实现的栈，通过连续内存存储元素，依赖栈顶指针（索引）管理元素的插入和删除。
#### 核心逻辑
##### 栈顶指针
初始化为$-1$（空栈），指向当前栈顶元素的位置。
##### 容量固定
数组大小预先定义，需处理栈满（溢出）和栈空（下溢）的边界条件。
##### 动态扩容（可选）
若需支持动态扩容，可在栈满时创建更大的数组并迁移数据。
#### `C++`实现
```C++ fold
#include <iostream>
using namespace std;

class SequentialStack {
private:
    int* data;       // 存储元素的数组
    int capacity;    // 栈的最大容量
    int topIdx;      // 栈顶指针（索引）

public:
    // 构造函数：初始化栈
    SequentialStack(int size) : capacity(size), topIdx(-1) {
        data = new int[capacity];
    }

    // 析构函数：释放内存
    ~SequentialStack() {
        delete[] data;
    }

    // 入栈：元素添加到栈顶
    void push(int value) {
        if (isFull()) {
            cerr << "Error: Stack Overflow" << endl;
            return;
        }
        data[++topIdx] = value;  // 先移动指针，再赋值
    }

    // 出栈：删除栈顶元素
    void pop() {
        if (isEmpty()) {
            cerr << "Error: Stack Underflow" << endl;
            return;
        }
        topIdx--;
    }

    // 获取栈顶元素（不删除）
    int top() {
        if (isEmpty()) {
            cerr << "Error: Stack is Empty" << endl;
            return -1; // 可根据需求抛出异常
        }
        return data[topIdx];
    }

    // 判断栈是否为空
    bool isEmpty() {
        return topIdx == -1;
    }

    // 判断栈是否已满
    bool isFull() {
        return topIdx == capacity - 1;
    }
};

// 测试示例
int main() {
    SequentialStack stack(3);
    stack.push(10);
    stack.push(20);
    stack.push(30);
    stack.push(40); // 触发溢出提示

    cout << "Top: " << stack.top() << endl; // 30
    stack.pop();
    cout << "Top: " << stack.top() << endl; // 20
    return 0;
}
```
### 链式栈
基于链表实现的栈，通过节点动态分配内存，元素存储在非连续的空间中，依赖指针连接。
#### 核心逻辑
##### 节点结构
每个节点包含数据域和指向下一节点的指针。  
##### 栈顶指针
始终指向链表的头结点（栈顶元素）。  
##### 动态内存
无需预先分配固定容量，插入/删除仅操作链表头部。  
#### `C++`实现
```C++ fold
#include <iostream>
using namespace std;

// 链表节点定义
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

class LinkedStack {
private:
    ListNode* topNode;  // 栈顶指针

public:
    LinkedStack() : topNode(nullptr) {}

    ~LinkedStack() {
        // 析构时释放所有节点内存
        while (!isEmpty()) {
            pop();
        }
    }

    // 入栈：在链表头部插入新节点
    void push(int value) {
        ListNode* newNode = new ListNode(value);
        newNode->next = topNode;  // 新节点指向原栈顶
        topNode = newNode;        // 更新栈顶指针
    }

    // 出栈：删除链表头部节点
    void pop() {
        if (isEmpty()) {
            cerr << "Error: Stack Underflow" << endl;
            return;
        }
        ListNode* temp = topNode;  // 暂存待删除节点
        topNode = topNode->next;   // 栈顶指针下移
        delete temp;              // 释放内存
    }

    // 获取栈顶元素
    int top() {
        if (isEmpty()) {
            cerr << "Error: Stack is Empty" << endl;
            return -1;  // 可改为抛出异常
        }
        return topNode->val;
    }

    // 判断栈是否为空
    bool isEmpty() {
        return topNode == nullptr;
    }
};

// 测试示例
int main() {
    LinkedStack stack;
    stack.push(10);
    stack.push(20);
    stack.push(30);

    cout << "Top: " << stack.top() << endl; // 30
    stack.pop();
    cout << "Top: " << stack.top() << endl; // 20
    return 0;
}
```
### 顺序栈与链式栈的比较

| **特性** | 顺序栈            | 链式栈           |
| ------ | -------------- | ------------- |
| 内存分配   | 连续内存（预分配数组）    | 动态分配（节点分散）    |
| 扩容方式   | 需复制数据（动态扩容时）   | 无需扩容，按需分配节点   |
| 访问速度   | 快（连续内存，缓存命中率高） | 慢（指针跳转，缓存不友好） |
| 空间开销   | 无额外指针空间        | 每个节点额外存储指针    |
| 适用场景   | 元素数量可控或需要高速访问  | 元素数量动态变化      |
### 栈的应用
#### 中缀表达式与后缀表达式
##### 中缀表达式
###### 定义
运算符位于两个操作数中间，例如：$A+B$、$(3*4)+5$。
###### 特点
1. 需处理运算符优先级：例如：$3+5*2$中，$*$优先级高于$+$。
2. 依赖括号改变优先级：例如：$(3+5)*2$。
3. 符合人类的自然书写习惯，但对计算机不友好，需要额外的算法（如栈）来解析和计算。
##### 后缀表达式
###### 定义
运算符位于两个操作数之后，例如：$A\ B\ +$、$3\ \ 4\ *\ 5\ +$。
###### 特点
1. 无优先级和括号：运算符顺序直接决定计算顺序。
2. 计算机友好：只需从左到右扫描，用栈即可完成计算。
3. 转换依赖栈：中缀转后缀需要借助栈处理运算符优先级。
#### 表达式求值
##### 中缀转后缀表达式
利用栈处理操作符优先级（如$*\ /$高于$+\ -$）。
###### 步骤
1. 遇到操作数直接输出。
2. 遇到左括号压栈。
3. 遇到右括号，弹栈输出直到左括号。
4. 遇到操作符，弹栈输出优先级更高或相等的操作符，在压入当前操作符。
```
3 + 4 * 2 / (1 - 5)
3 
> +

3 4
> + *

3 4 2 *
> + /

3 4 2 * 1 5
> + / -

3 4 2 * 1 5 - / +
```
##### 后缀表达式计算
###### 步骤
1. 遇到操作数压栈
2. 遇到操作符，弹出两个操作数计算，结果压栈。
3. 最终栈顶为结果。
```
3 4 2 * 1 5 - / +
> 3 4 2
4 2 *

> 3 8 1 5
1 5 -

> 3 8 -4
8 -4 /

> 3 -2
3 -2 +

> 1
```
#### 递归转非递归
##### 核心思路
手动维护显示栈来模拟系统隐式保存函数调用状态这一过程。
##### 通用转换步骤
###### 定义栈帧结构体
记录递归函数的状态，包括
1. 参数：与递归函数参数一致。
2. 局部变量：函数内的临时变量。
3. 执行阶段：标记当前处理到递归的哪一步。
###### 初始化栈
将初始状态压入栈中，模拟首次递归调用。
###### 循环处理栈帧
不断弹出栈顶帧，分阶段处理，模拟递归展开和返回。
##### 性能与适用性
###### 优点
- 避免栈溢出：手动栈可使用堆内存（如`std::stack`默认基于`deque`），突破系统栈限制。
- 完全控制流程：可优化执行顺序（如广度优先遍历）。
###### 缺点
- 代码复杂度高：需要手动管理状态和阶段。
- 可读性下降：不如递归直观。
##### 示例（斐波那契数列）
###### 递归版本
```C++
int fib(int n) {
    if (n <= 1) return n;
    return fib(n-1) + fib(n-2); // 非尾递归，需保存中间结果
}
```
###### 非递归（显示栈+结果合并）
```C++
struct FibFrame {
    int n;
    int stage;
    int result; // 保存子问题结果
};

int fib_nonrecursive(int n) {
    stack<FibFrame> s;
    s.push({n, 0, 0});
    int final_result = 0;

    while (!s.empty()) {
        auto curr = s.top();
        s.pop();

        if (curr.stage == 0) {
            if (curr.n <= 1) {
                final_result = curr.n; // 基线条件
                continue;
            }

            // 阶段0：处理 fib(n-1)
            curr.stage = 1;
            s.push(curr);
            s.push({curr.n - 1, 0, 0}); // 子问题 fib(n-1)
        } else if (curr.stage == 1) {
            // 阶段1：保存 fib(n-1) 的结果，处理 fib(n-2)
            FibFrame parent = s.top();
            s.pop();
            parent.result = final_result; // 保存左子树结果
            parent.stage = 2;
            s.push(parent);
            s.push({curr.n - 2, 0, 0}); // 子问题 fib(n-2)
        } else if (curr.stage == 2) {
            // 阶段2：合并结果
            final_result = curr.result + final_result; // 左结果 + 右结果
        }
    }

    return final_result;
}
```
##### 尾递归
尾递归是递归的一种特殊形式，递归调用是函数中的最后一个操作，且返回值直接传递，无需在当前栈帧中进行额外计算。编译器可将其优化为循环，避免栈溢出。
###### 优化原理
1. 复用栈帧：尾递归的返回值直接传递，无需保留当前函数的上下文。
2. 等效循环：编译器将其转换为循环，节省内存。
## 栈与递归
### 递归的概念
若一个对象部分地包含它自己，或用它自己给自己定义，则称这个对象是递归的；而且若一个过程直接地或间接地调用自己，则称这个过程是递归的过程。
### 需要用到递归的情况
#### 定义是递归的
数学上常用的阶乘函数、幂函数、斐波那契数列等，它们的定义和计算都是递归的。
##### 分治法
分而治之的递归求解方法。对于一个较为复杂的问题，如果能分解成几个相对简单的且解法相同或类似的子问题时，只要解决了这些子问题，那么原问题就迎刃而解。
##### 递归结束条件
当分解后的子问题可以直接解决时，就停止分解。
##### 递归过程直接反映了定义的结构
递归定义的函数可以用递归过程来编程求解。
#### 数据结构是递归的
对于递归的数据结构，采用递归的方法来编写算法特别方便。
##### 递归的数据结构
1. 链表
2. 树
#### 问题的解法是递归的

## 队列
队列（$queue$）是一种先进先出（$FIFO,First-In-First-Out$）的线性数据结构。它只允许在表的一端插入，在另一端删除。允许插入的一端叫做队尾（$rear$）允许删除的一端叫做对头（$front$）。
### 基本操作
- 入队（`Enqueue`）：在队尾添加元素。
- 出队（`Dequeue`）：从队头移除元素。
- 查看队头（`Fornt`）：获取对头元素。
- 判空（`isEmpty`）：检查队列是否为空。
- 判满（`isFull`）：固定大小队列需要（如数组实现的队列）。
### 顺序队列
基于数组的存储表示的队列。
#### 描述
利用一个一维数组`elements[maxSize]`作为队列元素的存储结构，并设置两个指针`front`和`rear`，分别只是队列的对头和队尾位置。
#### 循环队列
把数组的前端和后端连接起来，形成一个环形的表，即把存储队列元素的表从逻辑上看成一个环。循环队列可充分地利用数组中的存储空间。
## 字符串